# -*- coding: utf-8 -*-
"""
ASTROFLORA BACKEND - INTERFACES DE SERVICIOS REFINADAS
LUIS: Interfaces específicas para cada servicio del sistema.
"""
from typing import Protocol, Any, Optional, Dict, List
from src.models.analysis import (
    AnalysisRequest, AnalysisContext, JobPayload, PromptProtocol, 
    ToolResult, EventStoreEntry, SequenceData, BlastResult, UniProtResult, LLMResult, PipelineResult
)
import uuid

# ============================================================================
# INTERFACES PRINCIPALES DEL SISTEMA
# ============================================================================

class IMetricsService(Protocol):
    """Contrato para el servicio de métricas."""
    def record_analysis_started(self) -> None: ...
    def record_analysis_completed(self, duration_ms: float) -> None: ...
    def record_analysis_failed(self) -> None: ...
    def record_job_queued(self) -> None: ...
    def record_external_call(self, service_name: str, duration_ms: float) -> None: ...
    def record_external_call_failure(self, service_name: str) -> None: ...
    def record_driver_ia_invocation(self, protocol_type: str) -> None: ...
    def record_pipeline_step(self, step_name: str, duration_ms: float, success: bool) -> None: ...

class ICapacityManager(Protocol):
    """Contrato para gestionar la capacidad del sistema."""
    async def can_process_request(self) -> bool: ...
    async def add_to_waitlist(self, context_id: str) -> int: ...
    async def get_next_from_waitlist(self) -> Optional[str]: ...
    async def record_job_started(self) -> None: ...
    async def record_job_finished(self) -> None: ...
    async def get_current_capacity(self) -> Dict[str, int]: ...

class ICircuitBreaker(Protocol):
    """Contrato para el Circuit Breaker."""
    async def call(self, async_func: callable, *args, **kwargs) -> Any: ...
    async def is_open(self) -> bool: ...
    async def reset(self) -> None: ...
    async def get_status(self) -> Dict[str, Any]: ...
class ICircuitBreakerFactory(Protocol):
    """Contrato para la fábrica de Circuit Breakers."""
    def create_circuit_breaker(self, service_name: str) -> ICircuitBreaker: ...

class ISQSDispatcher(Protocol):
    """Contrato para el despachador de trabajos a SQS."""
    async def dispatch_analysis_job(self, payload: JobPayload) -> None: ...
    async def get_queue_status(self) -> Dict[str, Any]: ...

# ============================================================================
# INTERFACES DE DATOS Y PERSISTENCIA
# ============================================================================

class IEventStore(Protocol):
    """Contrato para el almacén de eventos."""
    async def store_event(self, event: EventStoreEntry) -> None: ...
    async def get_events(self, context_id: str) -> List[EventStoreEntry]: ...
    async def get_events_by_type(self, event_type: str) -> List[EventStoreEntry]: ...
    async def get_performance_metrics(self, context_id: str) -> Dict[str, Any]: ...
    async def get_usage_statistics(self) -> Dict[str, Any]: ...

class IContextManager(Protocol):
    """Contrato para gestionar el contexto de análisis."""
    async def create_context(self, request: AnalysisRequest, user_id: str) -> AnalysisContext: ...
    async def get_context(self, context_id: str) -> Optional[AnalysisContext]: ...
    async def update_context(self, context: AnalysisContext) -> None: ...
    async def update_progress(self, context_id: str, progress: int, step: str) -> None: ...
    async def set_results(self, context_id: str, results: Dict[str, Any]) -> None: ...
    async def mark_failed(self, context_id: str, error_message: str) -> None: ...
    async def mark_completed(self, context_id: str) -> None: ...

class IDatabaseService(Protocol):
    """Contrato para servicios de base de datos."""
    async def get_connection(self) -> Any: ...
    async def execute_query(self, query: str, params: Dict[str, Any] = None) -> Any: ...
    async def health_check(self) -> bool: ...

# ============================================================================
# INTERFACES DE SERVICIOS DE IA Y ANÁLISIS
# ============================================================================

class IToolGateway(Protocol):
    """Contrato para el gateway de herramientas."""
    async def invoke_tool(self, tool_name: str, parameters: Dict[str, Any]) -> ToolResult: ...
    async def get_available_tools(self) -> List[str]: ...
    async def health_check_tool(self, tool_name: str) -> bool: ...

class IDriverIA(Protocol):
    """Contrato para el Driver IA - el cerebro del sistema."""
    async def execute_protocol(self, protocol: PromptProtocol, context: AnalysisContext) -> None: ...
    async def generate_protocol(self, request: AnalysisRequest) -> PromptProtocol: ...
    async def analyze_results(self, context_id: str, results: Dict[str, Any]) -> Dict[str, Any]: ...

class ILLMService(Protocol):
    """Contrato para servicios de LLM."""
    async def analyze_sequence_data(self, prompt: str, max_tokens: int = 1000, temperature: float = 0.3) -> Dict[str, Any]: ...
    async def generate_summary(self, data: Dict[str, Any]) -> str: ...
    async def health_check(self) -> bool: ...

# ============================================================================
# INTERFACES ESPECÍFICAS PARA SERVICIOS BIOINFORMÁTICOS
# ============================================================================

class IBlastService(Protocol):
    """Contrato para servicios BLAST."""
    async def search_homology(self, sequence: str, database: str = "nr", max_hits: int = 50) -> BlastResult: ...
    async def search_local_database(self, sequence: str, database_path: str) -> BlastResult: ...
    async def health_check(self) -> bool: ...

class IUniProtService(Protocol):
    """Contrato para servicios UniProt."""
    async def get_protein_annotations(self, protein_ids: List[str]) -> UniProtResult: ...
    async def search_by_function(self, function_term: str) -> List[Dict[str, Any]]: ...
    async def get_protein_details(self, protein_id: str) -> Dict[str, Any]: ...
    async def health_check(self) -> bool: ...

class ISequenceService(Protocol):
    """Contrato para servicios de análisis de secuencias."""
    async def validate_sequence(self, sequence: str, sequence_type: str) -> bool: ...
    async def compute_features(self, sequence: str) -> Dict[str, Any]: ...
    async def translate_sequence(self, dna_sequence: str) -> str: ...

# ============================================================================
# INTERFACES DEL PIPELINE CIENTÍFICO
# ============================================================================

class IPipelineService(Protocol):
    """Contrato para el pipeline científico principal."""
    async def run_batch_analysis(self, sequences: List[SequenceData]) -> Dict[str, Any]: ...
    async def get_pipeline_status(self) -> Dict[str, Any]: ...

class IPipelineStep(Protocol):
    """Contrato para pasos individuales del pipeline."""
    async def execute(self, input_data: Any) -> Dict[str, Any]: ...
    async def validate_input(self, input_data: Any) -> bool: ...
    def get_step_name(self) -> str: ...

# ============================================================================
# INTERFACES DE ORQUESTACIÓN Y WORKERS
# ============================================================================

class IOrchestrator(Protocol):
    """Contrato para el orquestador principal."""
    async def start_new_analysis(self, request: AnalysisRequest, user_id: str) -> AnalysisContext: ...
    async def process_analysis_from_queue(self, payload: JobPayload) -> None: ...
    async def get_analysis_status(self, context_id: str) -> Optional[AnalysisContext]: ...
    async def cancel_analysis(self, context_id: str) -> bool: ...
    async def run_pipeline_batch(self, sequences: List[SequenceData]) -> Dict[str, Any]: ...

class IAnalysisWorker(Protocol):
    """Contrato para el worker de análisis."""
    async def process_job(self, payload: JobPayload) -> None: ...
    async def process_pipeline_job(self, sequences: List[SequenceData]) -> Dict[str, Any]: ...
    async def health_check(self) -> bool: ...

class IPipelineWorker(Protocol):
    """Contrato específico para workers del pipeline."""
    async def execute_pipeline(self, sequences: List[SequenceData]) -> Dict[str, Any]: ...
    async def get_worker_status(self) -> Dict[str, Any]: ...

# ============================================================================
# INTERFACES DE LOGGING Y OBSERVABILIDAD
# ============================================================================

class IStructuredLogger(Protocol):
    """Contrato para logging estructurado."""
    def log_pipeline_step(self, step_name: str, context_id: str, data: Dict[str, Any]) -> None: ...
    def log_error(self, error: Exception, context: Dict[str, Any]) -> None: ...
    def log_metric(self, metric_name: str, value: float, tags: Dict[str, str] = None) -> None: ...

class IHealthChecker(Protocol):
    """Contrato para health checks."""
    async def check_service_health(self, service_name: str) -> Dict[str, Any]: ...
    async def check_all_services(self) -> Dict[str, Any]: ...
    async def get_system_metrics(self) -> Dict[str, Any]: ...