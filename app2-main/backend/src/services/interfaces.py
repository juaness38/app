# -*- coding: utf-8 -*-
"""
ASTROFLORA - INTERFACES DE SERVICIOS HÍBRIDAS
Interfaces para sensores IoT + análisis científico
"""
from typing import Protocol, Any, Optional, Dict, List
from abc import ABC, abstractmethod
from src.models.dto import SensorData

# ============================================================================
# INTERFACES DE SENSORES IOT (TU CÓDIGO ACTUAL)
# ============================================================================

class ISensorService(Protocol):
    """Servicio de sensores IoT."""
    @abstractmethod
    async def ingest_sensor_data(self, data: SensorData) -> None: ...
    
    @abstractmethod
    async def ingest_full_sensor_data(self, data: SensorData) -> None: ...

# ============================================================================
# INTERFACES DE ANÁLISIS CIENTÍFICO (INTEGRADAS)
# ============================================================================

class IMetricsService(Protocol):
    """Servicio de métricas y observabilidad."""
    def record_analysis_started(self) -> None: ...
    def record_analysis_completed(self, duration_ms: float) -> None: ...
    def record_analysis_failed(self) -> None: ...
    def record_job_queued(self) -> None: ...
    def record_external_call(self, service_name: str, duration_ms: float) -> None: ...
    def record_external_call_failure(self, service_name: str) -> None: ...
    def set_current_capacity(self, current_count: int) -> None: ...

class ICapacityManager(Protocol):
    """Gestor de capacidad del sistema."""
    async def can_process_request(self) -> bool: ...
    async def add_to_waitlist(self, context_id: str) -> int: ...
    async def get_next_from_waitlist(self) -> Optional[str]: ...
    async def record_job_started(self) -> None: ...
    async def record_job_finished(self) -> None: ...
    async def get_current_capacity(self) -> Dict[str, int]: ...

class ICircuitBreaker(Protocol):
    """Circuit Breaker para protección de servicios."""
    async def call(self, async_func: callable, *args, **kwargs) -> Any: ...
    async def is_open(self) -> bool: ...
    async def reset(self) -> None: ...
    async def get_status(self) -> Dict[str, Any]: ...

class ISQSDispatcher(Protocol):
    """Dispatcher para cola de análisis."""
    async def dispatch_analysis_job(self, payload: Any) -> None: ...
    async def get_queue_status(self) -> Dict[str, Any]: ...

# ============================================================================
# INTERFACES DE DATOS (ADAPTADAS A POSTGRESQL)
# ============================================================================

class IContextManager(Protocol):
    """Gestión de contextos de análisis con PostgreSQL."""
    async def create_context(self, request: Any, user_id: str) -> Any: ...
    async def get_context(self, context_id: str) -> Optional[Any]: ...
    async def update_context(self, context: Any) -> None: ...
    async def update_progress(self, context_id: str, progress: int, step: str) -> None: ...
    async def set_results(self, context_id: str, results: Dict[str, Any]) -> None: ...
    async def mark_failed(self, context_id: str, error_message: str) -> None: ...
    async def mark_completed(self, context_id: str) -> None: ...
    async def get_contexts_by_user(self, user_id: str, limit: int) -> List[Any]: ...

class IEventStore(Protocol):
    """Event Store para auditoría con PostgreSQL."""
    async def store_event(self, event: Any) -> None: ...
    async def get_events(self, context_id: str) -> List[Any]: ...
    async def get_events_by_type(self, event_type: str) -> List[Any]: ...
    async def get_performance_metrics(self, context_id: str) -> Dict[str, Any]: ...
    async def get_usage_statistics(self) -> Dict[str, Any]: ...
    async def cleanup_old_events(self) -> int: ...

# ============================================================================
# INTERFACES DE IA Y ANÁLISIS CIENTÍFICO
# ============================================================================

class IToolGateway(Protocol):
    """Gateway para herramientas bioinformáticas."""
    async def invoke_tool(self, tool_name: str, parameters: Dict[str, Any]) -> Any: ...
    async def get_available_tools(self) -> List[str]: ...
    async def health_check_tool(self, tool_name: str) -> bool: ...
    async def close(self) -> None: ...

class IDriverIA(Protocol):
    """Driver IA - cerebro del análisis científico."""
    async def execute_protocol(self, protocol: Any, context: Any) -> None: ...
    async def generate_protocol(self, request: Any) -> Any: ...
    async def analyze_results(self, context_id: str, results: Dict[str, Any]) -> Dict[str, Any]: ...
    async def close(self) -> None: ...

class ILLMService(Protocol):
    """Servicios de LLM."""
    async def analyze_sequence_data(self, prompt: str, max_tokens: int = 1000, temperature: float = 0.3) -> Dict[str, Any]: ...
    async def generate_summary(self, data: Dict[str, Any]) -> str: ...
    async def health_check(self) -> bool: ...

# ============================================================================
# INTERFACES DE SERVICIOS BIOINFORMÁTICOS (APIs REALES)
# ============================================================================

class IBlastService(Protocol):
    """Servicio BLAST real."""
    async def search_homology(self, sequence: str, database: str = "nr", max_hits: int = 50) -> Any: ...
    async def search_local_database(self, sequence: str, database_path: str) -> Any: ...
    async def health_check(self) -> bool: ...

class IUniProtService(Protocol):
    """Servicio UniProt real."""
    async def get_protein_annotations(self, protein_ids: List[str]) -> Any: ...
    async def search_by_function(self, function_term: str) -> List[Dict[str, Any]]: ...
    async def get_protein_details(self, protein_id: str) -> Dict[str, Any]: ...
    async def health_check(self) -> bool: ...

class IPipelineService(Protocol):
    """Pipeline científico principal."""
    async def run_batch_analysis(self, sequences: List[Any]) -> Dict[str, Any]: ...
    async def get_pipeline_status(self) -> Dict[str, Any]: ...

# ============================================================================
# INTERFACES DE ORQUESTACIÓN
# ============================================================================

class IOrchestrator(Protocol):
    """Orquestador principal del sistema."""
    async def start_new_analysis(self, request: Any, user_id: str) -> Any: ...
    async def process_analysis_from_queue(self, payload: Any) -> None: ...
    async def get_analysis_status(self, context_id: str) -> Optional[Any]: ...
    async def cancel_analysis(self, context_id: str) -> bool: ...
    async def get_user_analyses(self, user_id: str, limit: int = 50) -> list: ...
    async def get_system_stats(self) -> dict: ...
    async def health_check(self) -> dict: ...

class IAnalysisWorker(Protocol):
    """Worker de análisis científico."""
    async def process_job(self, payload: Any) -> None: ...
    async def health_check(self) -> bool: ...
    async def get_worker_stats(self) -> Dict[str, Any]: ...
    async def shutdown(self) -> None: ...